---
phase: 61-foundation
plan: 02
type: execute
---

<objective>
Implement authentication with email/password and Google Sign-in.

Purpose: Enable users to sign in using existing web credentials.
Output: Working auth flow with SecureStore token persistence.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/61-foundation/61-01-SUMMARY.md
@plan.md

# Web auth implementation (reference)
@lib/auth.ts

# Existing API routes
@app/api/auth/[...nextauth]/route.ts

**Auth strategy:**
- Use existing NextAuth API endpoints
- Store session token in Expo SecureStore
- Pass token as Authorization header for API calls

**Dependencies from 61-01:**
- Expo project with expo-secure-store plugin
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API client with token management</name>
  <files>apps/mobile/lib/api.ts, apps/mobile/lib/storage.ts</files>
  <action>
1. Create `lib/storage.ts` with SecureStore wrapper:

```typescript
import * as SecureStore from 'expo-secure-store';

const TOKEN_KEY = 'auth_token';
const USER_KEY = 'user_data';

export async function getToken(): Promise<string | null> {
  return SecureStore.getItemAsync(TOKEN_KEY);
}

export async function setToken(token: string): Promise<void> {
  await SecureStore.setItemAsync(TOKEN_KEY, token);
}

export async function clearToken(): Promise<void> {
  await SecureStore.deleteItemAsync(TOKEN_KEY);
}

export async function getUser<T>(): Promise<T | null> {
  const data = await SecureStore.getItemAsync(USER_KEY);
  return data ? JSON.parse(data) : null;
}

export async function setUser<T>(user: T): Promise<void> {
  await SecureStore.setItemAsync(USER_KEY, JSON.stringify(user));
}

export async function clearUser(): Promise<void> {
  await SecureStore.deleteItemAsync(USER_KEY);
}
```

2. Create `lib/api.ts` with fetch wrapper:

```typescript
import Constants from 'expo-constants';
import { getToken, clearToken, clearUser } from './storage';

const API_BASE = Constants.expoConfig?.extra?.apiBaseUrl ?? 'https://mk-language-lab.vercel.app';

interface FetchOptions extends RequestInit {
  skipAuth?: boolean;
}

export async function apiFetch<T>(
  endpoint: string,
  options: FetchOptions = {}
): Promise<T> {
  const { skipAuth, ...fetchOptions } = options;

  const headers: HeadersInit = {
    'Content-Type': 'application/json',
    ...fetchOptions.headers,
  };

  if (!skipAuth) {
    const token = await getToken();
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }
  }

  const response = await fetch(`${API_BASE}${endpoint}`, {
    ...fetchOptions,
    headers,
  });

  if (response.status === 401) {
    // Token expired, clear auth state
    await clearToken();
    await clearUser();
    throw new AuthError('Session expired');
  }

  if (!response.ok) {
    throw new ApiError(response.status, await response.text());
  }

  return response.json();
}

export class AuthError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'AuthError';
  }
}

export class ApiError extends Error {
  constructor(public status: number, message: string) {
    super(message);
    this.name = 'ApiError';
  }
}
```

3. Add dependencies to package.json:
   - expo-secure-store
   - expo-constants
  </action>
  <verify>cd apps/mobile && npx tsc --noEmit</verify>
  <done>lib/api.ts and lib/storage.ts exist with token management, types check</done>
</task>

<task type="auto">
  <name>Task 2: Create auth store and sign-in screen</name>
  <files>apps/mobile/store/auth.ts, apps/mobile/app/sign-in.tsx, apps/mobile/lib/auth.ts</files>
  <action>
1. Create `store/auth.ts` with Zustand:

```typescript
import { create } from 'zustand';
import { getToken, setToken, clearToken, getUser, setUser, clearUser } from '../lib/storage';

interface User {
  id: string;
  email: string;
  name: string | null;
  image: string | null;
}

interface AuthState {
  user: User | null;
  isLoading: boolean;
  isAuthenticated: boolean;

  // Actions
  initialize: () => Promise<void>;
  signIn: (email: string, password: string) => Promise<void>;
  signInWithGoogle: (idToken: string) => Promise<void>;
  signOut: () => Promise<void>;
}

export const useAuthStore = create<AuthState>((set, get) => ({
  user: null,
  isLoading: true,
  isAuthenticated: false,

  initialize: async () => {
    try {
      const token = await getToken();
      const user = await getUser<User>();

      if (token && user) {
        set({ user, isAuthenticated: true, isLoading: false });
      } else {
        set({ isLoading: false });
      }
    } catch {
      set({ isLoading: false });
    }
  },

  signIn: async (email, password) => {
    // Call NextAuth credentials endpoint
    const response = await fetch(`${API_BASE}/api/auth/callback/credentials`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    });

    if (!response.ok) {
      throw new Error('Invalid credentials');
    }

    const data = await response.json();
    await setToken(data.token);
    await setUser(data.user);
    set({ user: data.user, isAuthenticated: true });
  },

  signInWithGoogle: async (idToken) => {
    // Exchange Google token with backend
    const response = await fetch(`${API_BASE}/api/auth/callback/google`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ idToken }),
    });

    if (!response.ok) {
      throw new Error('Google sign-in failed');
    }

    const data = await response.json();
    await setToken(data.token);
    await setUser(data.user);
    set({ user: data.user, isAuthenticated: true });
  },

  signOut: async () => {
    await clearToken();
    await clearUser();
    set({ user: null, isAuthenticated: false });
  },
}));
```

2. Add zustand to package.json dependencies

3. Create `app/sign-in.tsx` screen:

```typescript
import { useState } from 'react';
import { View, Text, TextInput, TouchableOpacity, ActivityIndicator, KeyboardAvoidingView, Platform } from 'react-native';
import { Link, router } from 'expo-router';
import { useAuthStore } from '../store/auth';

export default function SignInScreen() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const signIn = useAuthStore((s) => s.signIn);

  const handleSignIn = async () => {
    if (!email || !password) {
      setError('Please enter email and password');
      return;
    }

    setIsLoading(true);
    setError('');

    try {
      await signIn(email, password);
      router.replace('/(tabs)');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Sign in failed');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <KeyboardAvoidingView
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      className="flex-1 bg-background"
    >
      <View className="flex-1 justify-center px-6">
        <Text className="text-3xl font-bold text-white mb-8 text-center">
          MK Language Lab
        </Text>

        {error ? (
          <View className="bg-red-500/20 p-3 rounded-lg mb-4">
            <Text className="text-red-400 text-center">{error}</Text>
          </View>
        ) : null}

        <TextInput
          className="bg-surface border border-border rounded-lg p-4 text-white mb-4"
          placeholder="Email"
          placeholderTextColor="#666"
          value={email}
          onChangeText={setEmail}
          autoCapitalize="none"
          keyboardType="email-address"
        />

        <TextInput
          className="bg-surface border border-border rounded-lg p-4 text-white mb-6"
          placeholder="Password"
          placeholderTextColor="#666"
          value={password}
          onChangeText={setPassword}
          secureTextEntry
        />

        <TouchableOpacity
          className="bg-accent py-4 rounded-lg items-center mb-4"
          onPress={handleSignIn}
          disabled={isLoading}
        >
          {isLoading ? (
            <ActivityIndicator color="#000" />
          ) : (
            <Text className="text-black font-semibold text-lg">Sign In</Text>
          )}
        </TouchableOpacity>

        <Link href="/register" asChild>
          <TouchableOpacity className="py-2">
            <Text className="text-textMuted text-center">
              Don't have an account? <Text className="text-accent">Sign up</Text>
            </Text>
          </TouchableOpacity>
        </Link>

        <Link href="/forgot-password" asChild>
          <TouchableOpacity className="py-2">
            <Text className="text-textMuted text-center">Forgot password?</Text>
          </TouchableOpacity>
        </Link>
      </View>
    </KeyboardAvoidingView>
  );
}
```

**Note:** This uses NativeWind classes. We'll set up NativeWind in Task 3.
  </action>
  <verify>cd apps/mobile && npx tsc --noEmit</verify>
  <done>Auth store created, sign-in screen renders (styling comes next)</done>
</task>

<task type="auto">
  <name>Task 3: Add Google Sign-in and NativeWind</name>
  <files>apps/mobile/app/sign-in.tsx, apps/mobile/tailwind.config.js, apps/mobile/global.css, apps/mobile/package.json</files>
  <action>
1. Add NativeWind to the project:
   - Add dependencies: nativewind, tailwindcss
   - Create `tailwind.config.js` with content paths
   - Create `global.css` with @tailwind directives
   - Update `babel.config.js` to include nativewind/babel

2. Create `tailwind.config.js`:

```javascript
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ['./app/**/*.{js,jsx,ts,tsx}', './components/**/*.{js,jsx,ts,tsx}'],
  presets: [require('nativewind/preset')],
  theme: {
    extend: {
      colors: {
        background: '#06060b',
        surface: '#0b0b12',
        surfaceRaised: '#111424',
        border: '#222536',
        text: '#f7f8fb',
        textMuted: 'rgba(247,248,251,0.72)',
        accent: '#f6d83b',
        success: '#3ecf8e',
        danger: '#ff7878',
      },
    },
  },
  plugins: [],
};
```

3. Add Google Sign-in:
   - Add expo-auth-session dependency
   - Add expo-web-browser dependency

4. Update sign-in screen with Google button:

```typescript
import * as Google from 'expo-auth-session/providers/google';
import * as WebBrowser from 'expo-web-browser';

WebBrowser.maybeCompleteAuthSession();

// In component:
const [request, response, promptAsync] = Google.useAuthRequest({
  androidClientId: process.env.EXPO_PUBLIC_GOOGLE_ANDROID_CLIENT_ID,
  webClientId: process.env.EXPO_PUBLIC_GOOGLE_WEB_CLIENT_ID,
});

useEffect(() => {
  if (response?.type === 'success') {
    const { id_token } = response.params;
    signInWithGoogle(id_token);
  }
}, [response]);

// Add Google button:
<TouchableOpacity
  className="border border-border py-4 rounded-lg items-center flex-row justify-center"
  onPress={() => promptAsync()}
  disabled={!request}
>
  <Text className="text-white font-semibold">Continue with Google</Text>
</TouchableOpacity>
```

5. Add placeholder register and forgot-password screens:
   - `app/register.tsx` - basic form (wire to API later)
   - `app/forgot-password.tsx` - basic form (wire to API later)
  </action>
  <verify>cd apps/mobile && npx expo start --android (should launch without crash)</verify>
  <done>NativeWind styling works, Google Sign-in button present, placeholder auth screens exist</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] Auth store manages token in SecureStore
- [ ] Sign-in screen renders with email/password form
- [ ] Google Sign-in button present
- [ ] NativeWind classes apply correctly
- [ ] App launches without crash
</verification>

<success_criteria>

- Email/password sign-in flow implemented
- Google Sign-in configured (may need OAuth credentials)
- Auth state persists across app restarts
- Token passed in API requests
- Ready for navigation setup (next plan)
</success_criteria>

<output>
After completion, create `.planning/phases/61-foundation/61-02-SUMMARY.md`
</output>
