---
phase: 57-answer-evaluation
plan: 01
type: execute
---

<objective>
Wire LessonRunner FILL_BLANK validation to use Unicode normalization and Macedonian-specific answer analysis for richer feedback.

Purpose: Currently LessonRunner's FILL_BLANK validation does basic toLowerCase() comparison while the codebase has sophisticated analysis in unicode-normalize.ts (diacritics handling, article endings, gender agreement, verb conjugation hints). This phase connects that existing infrastructure to the lesson flow.

Output: FILL_BLANK answers receive detailed feedback hints like "Check the definite article ending (-от, -та, -то)" instead of generic "Not quite".
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./57-01-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/54-exercise-architecture-research/DISCOVERY.md
@.planning/phases/55-exercise-state-machine/55-01-SUMMARY.md
@.planning/phases/55-exercise-state-machine/55-02-SUMMARY.md
@.planning/phases/56-lesson-flow-progress/56-01-SUMMARY.md

**Key source files:**
@lib/unicode-normalize.ts - Unicode normalization and answer analysis (the source of truth)
@lib/lesson-runner/useLessonRunner.ts - LessonRunner hook with validateAnswer function
@lib/lesson-runner/types.ts - StepFeedback interface (message, correctAnswer, explanation)

**Architecture context (from Phase 54 DISCOVERY.md):**
- unicode-normalize.ts already has `analyzeAnswer()` that detects: diacritics, case, article, gender, conjugation, spelling mistakes
- useLessonRunner.ts FILL_BLANK validation uses basic string comparison
- grammar-engine.ts uses `validateAnswerWithFeedback()` but GrammarExerciseCard is legacy/unused
- The live path is: exercise-adapter → LessonRunner → useLessonRunner.validateAnswer

**Constraining decisions from prior phases:**
- Phase 55: SentenceBuilder and ErrorCorrection use exact word matching (not applicable for this phase)
- Phase 56: Progress persistence uses stepAnswers JSON - feedback enhancement doesn't affect storage
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unified validator wrapper</name>
  <files>lib/validation/unified-validator.ts</files>
  <action>
Create a unified validation module that wraps unicode-normalize functionality with a clean API for LessonRunner.

The module should export:
1. `validateTextAnswer(userAnswer: string, correctAnswer: string, options?: ValidationOptions): UnifiedValidationResult`
   - Uses `answersMatch()` from unicode-normalize for flexible comparison
   - Uses `analyzeAnswer()` to get feedback hints when incorrect
   - Returns both correctness AND analysis for feedback generation

2. `validateWithAlternatives(userAnswer: string, correctAnswer: string, alternatives: string[], options?: ValidationOptions): UnifiedValidationResult`
   - Same as above but checks alternatives array first

3. `generateFeedbackMessage(analysis: AnswerAnalysis, locale: 'en' | 'mk'): string`
   - Uses `getFeedbackMessage()` from unicode-normalize
   - Returns localized hint based on mistake type

Type definitions:
```typescript
interface ValidationOptions {
  caseSensitive?: boolean;  // Default: false (use flexible matching)
  strict?: boolean;         // Default: false (allow diacritic variations)
}

interface UnifiedValidationResult {
  isCorrect: boolean;
  analysis?: AnswerAnalysis;  // From unicode-normalize
  feedbackHint?: string;      // Localized message for UI
}
```

Re-export types from unicode-normalize for convenience:
```typescript
export { AnswerAnalysis } from '../unicode-normalize';
```

IMPORTANT: Do NOT duplicate logic from unicode-normalize. Import and wrap the existing functions.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit lib/validation/unified-validator.ts`</verify>
  <done>Module exports validateTextAnswer, validateWithAlternatives, generateFeedbackMessage with proper types</done>
</task>

<task type="auto">
  <name>Task 2: Wire LessonRunner FILL_BLANK to unified validator</name>
  <files>lib/lesson-runner/useLessonRunner.ts</files>
  <action>
Update the FILL_BLANK case in `validateAnswer()` function (around line 207) to use the unified validator.

Current implementation (simple):
```typescript
case 'FILL_BLANK': {
  const userAnswer = step.caseSensitive ? answer.answer.trim() : answer.answer.trim().toLowerCase();
  const correctAnswer = step.caseSensitive ? step.correctAnswer.trim() : step.correctAnswer.trim().toLowerCase();
  const acceptableAnswers = step.acceptableAnswers?.map(...) || [];
  const isCorrect = userAnswer === correctAnswer || acceptableAnswers.includes(userAnswer);
  return { isCorrect, feedback: { correct, message: isCorrect ? 'Correct!' : 'Not quite', ... } };
}
```

New implementation (with analysis):
```typescript
case 'FILL_BLANK': {
  // Use unified validator for rich feedback
  const validation = validateWithAlternatives(
    answer.answer,
    step.correctAnswer,
    step.acceptableAnswers || [],
    { caseSensitive: step.caseSensitive ?? false }
  );

  // Generate feedback message based on analysis
  let message = validation.isCorrect ? 'Correct!' : 'Not quite';
  if (!validation.isCorrect && validation.analysis?.mistakeType) {
    message = validation.feedbackHint || message;
  }

  return {
    isCorrect: validation.isCorrect,
    feedback: {
      correct: validation.isCorrect,
      message,
      correctAnswer: validation.isCorrect ? undefined : step.correctAnswer,
      explanation: step.explanation,
    },
  };
}
```

Add import at top of file:
```typescript
import { validateWithAlternatives } from './validation/unified-validator';
```

NOTE: Only modify FILL_BLANK case. Other step types (SENTENCE_BUILDER, ERROR_CORRECTION) use word-based matching which is intentionally different.
  </action>
  <verify>
1. `npm run type-check` passes
2. Manual test: Start lesson with fill-blank exercise, enter answer with wrong article ending (e.g., "куќа" instead of "куќата"), confirm feedback mentions article
  </verify>
  <done>FILL_BLANK validation uses unified validator and produces Macedonian-specific feedback hints</done>
</task>

<task type="auto">
  <name>Task 3: Add i18n feedback messages to translations</name>
  <files>messages/en.json, messages/mk.json</files>
  <action>
Add localized validation feedback messages to the translation files.

In `messages/en.json`, add to the `lessonRunner` namespace (or create `validation` namespace):
```json
"validation": {
  "correct": "Correct!",
  "incorrect": "Not quite",
  "hints": {
    "diacritics": "Almost! Check your diacritics and accents.",
    "case": "Watch your capitalization!",
    "punctuation": "Check your punctuation.",
    "spelling": "Check your spelling carefully.",
    "article": "Check the definite article! Remember: -от (m), -та (f), -то (n)",
    "gender": "Check gender agreement! Feminine nouns often end in -а",
    "conjugation": "Check your verb conjugation! Match the ending to the subject."
  }
}
```

In `messages/mk.json`, add matching translations:
```json
"validation": {
  "correct": "Точно!",
  "incorrect": "Не сосема",
  "hints": {
    "diacritics": "Скоро! Провери ги дијакритичките знаци.",
    "case": "Внимавај на големите букви!",
    "punctuation": "Провери ја интерпункцијата.",
    "spelling": "Провери го правописот.",
    "article": "Провери го членот! Запомни: -от (м), -та (ж), -то (с)",
    "gender": "Провери го родот! Женските именки завршуваат на -а",
    "conjugation": "Провери ја конјугацијата! Глаголот треба да се совпаѓа со субјектот."
  }
}
```

Note: These messages already exist in unicode-normalize.ts `getFeedbackMessage()`. Adding them to translation files enables future use with next-intl's `useTranslations` hook if LessonRunner components want to look up messages by key instead of relying on the validator.
  </action>
  <verify>JSON files are valid: `node -e "JSON.parse(require('fs').readFileSync('messages/en.json'))" && node -e "JSON.parse(require('fs').readFileSync('messages/mk.json'))"`</verify>
  <done>Both en.json and mk.json have validation.hints namespace with all mistake type messages</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run type-check` passes
- [ ] `npm run lint` passes
- [ ] New lib/validation/unified-validator.ts exists and exports validateTextAnswer, validateWithAlternatives
- [ ] useLessonRunner.ts imports and uses unified validator for FILL_BLANK
- [ ] Translation files have validation.hints namespace
</verification>

<success_criteria>
- FILL_BLANK answers use Unicode normalization for comparison
- Incorrect answers receive specific feedback based on mistake type (article, gender, conjugation, etc.)
- No regression in existing step type validation (MULTIPLE_CHOICE, SENTENCE_BUILDER, ERROR_CORRECTION)
- Both en.json and mk.json have matching validation hints
</success_criteria>

<output>
After completion, create `.planning/phases/57-answer-evaluation/57-01-SUMMARY.md`:

# Phase 57 Plan 01: Answer Evaluation Summary

**[Substantive one-liner - e.g., "Unified validator wires Macedonian grammar analysis to FILL_BLANK feedback"]**

## Accomplishments

- Created unified validator wrapper in lib/validation/
- Wired FILL_BLANK to use Unicode normalization
- Added localized feedback hint messages

## Files Created/Modified

- `lib/validation/unified-validator.ts` - New unified validation module
- `lib/lesson-runner/useLessonRunner.ts` - Updated FILL_BLANK validation
- `messages/en.json` - Added validation.hints namespace
- `messages/mk.json` - Added validation.hints namespace

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 57 complete. Ready for Phase 58: Audio Language.
</output>
